# If repressed and on, turn off
else if(!Gen.act & cur.val==1){
Time_Series$Values[Time_Series$Genes==Gene]<-0
assign(Gene,FALSE)
# Else, do nothing
}
}
}
}
}
# REDOING SIMULATION ARLGORITHM BASED OFF MABOSS METHOD
# Number of Simulations
N<-10000
# Maximum number of steps per simulation
K<-300
# Size of network
L<-num.genes-length(Input_Genes)
sims<-c()
# List of stable state outputs
Stable_States<-list(rep(NA,N))
for(j in 1:N){
go<-TRUE
#Creating random initial values of ALL genes
Data$Values[Data$Genes %in% c('ECMicroenv','DNAdamage','GF','TGFb_pthw')]<-sample(c(0,1),4,replace = T)
Data$Values[!Data$Genes %in% c('ECMicroenv','DNAdamage','GF','TGFb_pthw')]<-rep(0,num.genes-4)
for (i in 1:num.genes){
assign(Genes[i],as.logical(Data$Values[i]))
}
# Defining time series of JUST the variable genes
Time_Series<-Data[Data$Genes %in% Variable_Genes,]
for (k in 1:K){
sim<-1
while(go){
Cur.State<-Time_Series$Values
# Checking which components will change when updated
# I.e. which state changes are an asynchronous transition
Does.Change<-rep(FALSE,L)
for (l in 1:L){
Gen.act<-eval(parse(text=Time_Series$Rules[l]))
# If activated and off, change induced
if (Gen.act & Time_Series$Values[l]==0){
Does.Change[l]<-TRUE
}
# If repressed and on, change induced
if(!Gen.act & Time_Series$Values[l]==1){
Does.Change[l]<-TRUE
}
}
# Creating list of actual step-specific variable genes
Step_Variable_Genes<-Variable_Genes[Does.Change]
#print(Step_Variable_Genes)
if(length(Step_Variable_Genes)==0){
# Log the final value of the chain as the stable state for simulation j
Stable_States[[j]]<-c(Data$Values[Data$Genes %in% Input_Genes],Time_Series$Values)
sims<-append(sims,sim)
go<-FALSE
}
else{
# Then simply repeat the process as before
sim<-sim+1
Gene<-sample(Step_Variable_Genes,1)
# For the given gene,find its rule, current value, and whether it is being activated
Rule<-Data[Data$Genes==Gene,3]
Gen.act<-eval(parse(text=Rule))
cur.val<-Time_Series$Values[Time_Series$Genes==Gene]
# If activated and off, turn on
if (Gen.act & cur.val==0){
Time_Series$Values[Time_Series$Genes==Gene]<-1
assign(Gene,TRUE)
}
# If repressed and on, turn off
else if(!Gen.act & cur.val==1){
Time_Series$Values[Time_Series$Genes==Gene]<-0
assign(Gene,FALSE)
# Else, do nothing
}
}
}
}
}
# How many stable states there are (SHOULD BE 9 WITH NO GENE KNOCKOUTS)
length(unique(Stable_States))
# Probabilities of stable states
Probs<-c()
for (stable in unique(Stable_States)){
print(c(rev(Input_Genes),Variable_Genes)[as.logical(stable)])
count<-0
for (state in Stable_States){
if (all(state==stable)){
count <-count +1
}
}
Probs<-append(Probs,count/N)
}
# Printing stable states
Named_Stable_States<-list(rep(NA,num.genes))
g<-1
for (state in unique(Stable_States)){
#print(c(rev(Input_Genes),Variable_Genes)[as.logical(state)])
Named_Stable_States[[g]]<-c(rev(Input_Genes),Variable_Genes)[as.logical(state)]
g<-g+1
}
Named_Stable_States
MaBoSS_results<-read.csv('Models/Cohen_MaBoSS_out_fp.csv', sep = "\t",skip=1)
MaBoSS_results<-read.csv('Models/Cohen_MaBoSS_out_fp.csv', sep = "\t",skip=1)
MaBoSS_Probs<-MaBoSS_results$Proba
MaBoSS_Mat<-MaBoSS_results[,4:23]
n<-nrow(MaBoSS_Mat)
maboss_states<-list(rep(NA,n))
for(i in 1:n){
maboss_states[[i]]<-colnames(MaBoSS_Mat)[as.logical(MaBoSS_Mat[i,])]
}
maboss_states
new.order<-rep(0,9)
for (i in 1:9){
for(j in 1:9){
if(all(maboss_states[[i]] %in% Named_Stable_States[[j]]) & length(maboss_states[[i]])==length(Named_Stable_States[[j]])){
print(paste(i,"matched to ",j))
new.order[j]<-i
}
}
}
new.order
plot(Probs,ylim=c(0,1))
points(MaBoSS_Probs[new.order],col='red')
plot(Probs,ylim=c(0,.4))
points(MaBoSS_Probs[new.order],col='red')
# REDOING SIMULATION ARLGORITHM BASED OFF MABOSS METHOD
# Number of Simulations
N<-10000
# Maximum number of steps per simulation
K<-300
# Size of network
L<-num.genes-length(Input_Genes)
sims<-c()
# List of stable state outputs
Stable_States<-list(rep(NA,N))
for(j in 1:N){
go<-TRUE
#Creating random initial values of ALL genes
#Data$Values[Data$Genes %in% c('ECMicroenv','DNAdamage','GF','TGFb_pthw')]<-sample(c(0,1),4,replace = T)
#Data$Values[!Data$Genes %in% c('ECMicroenv','DNAdamage','GF','TGFb_pthw')]<-rep(0,num.genes-4)
Data$Values<-sample(c(0,1),num.genes,replace=TRUE)
for (i in 1:num.genes){
assign(Genes[i],as.logical(Data$Values[i]))
}
# Defining time series of JUST the variable genes
Time_Series<-Data[Data$Genes %in% Variable_Genes,]
for (k in 1:K){
sim<-1
while(go){
Cur.State<-Time_Series$Values
# Checking which components will change when updated
# I.e. which state changes are an asynchronous transition
Does.Change<-rep(FALSE,L)
for (l in 1:L){
Gen.act<-eval(parse(text=Time_Series$Rules[l]))
# If activated and off, change induced
if (Gen.act & Time_Series$Values[l]==0){
Does.Change[l]<-TRUE
}
# If repressed and on, change induced
if(!Gen.act & Time_Series$Values[l]==1){
Does.Change[l]<-TRUE
}
}
# Creating list of actual step-specific variable genes
Step_Variable_Genes<-Variable_Genes[Does.Change]
#print(Step_Variable_Genes)
if(length(Step_Variable_Genes)==0){
# Log the final value of the chain as the stable state for simulation j
Stable_States[[j]]<-c(Data$Values[Data$Genes %in% Input_Genes],Time_Series$Values)
sims<-append(sims,sim)
go<-FALSE
}
else{
# Then simply repeat the process as before
sim<-sim+1
Gene<-sample(Step_Variable_Genes,1)
# For the given gene,find its rule, current value, and whether it is being activated
Rule<-Data[Data$Genes==Gene,3]
Gen.act<-eval(parse(text=Rule))
cur.val<-Time_Series$Values[Time_Series$Genes==Gene]
# If activated and off, turn on
if (Gen.act & cur.val==0){
Time_Series$Values[Time_Series$Genes==Gene]<-1
assign(Gene,TRUE)
}
# If repressed and on, turn off
else if(!Gen.act & cur.val==1){
Time_Series$Values[Time_Series$Genes==Gene]<-0
assign(Gene,FALSE)
# Else, do nothing
}
}
}
}
}
# How many stable states there are (SHOULD BE 9 WITH NO GENE KNOCKOUTS)
length(unique(Stable_States))
# Probabilities of stable states
Probs<-c()
for (stable in unique(Stable_States)){
print(c(rev(Input_Genes),Variable_Genes)[as.logical(stable)])
count<-0
for (state in Stable_States){
if (all(state==stable)){
count <-count +1
}
}
Probs<-append(Probs,count/N)
}
# Printing stable states
Named_Stable_States<-list(rep(NA,num.genes))
g<-1
for (state in unique(Stable_States)){
#print(c(rev(Input_Genes),Variable_Genes)[as.logical(state)])
Named_Stable_States[[g]]<-c(rev(Input_Genes),Variable_Genes)[as.logical(state)]
g<-g+1
}
Named_Stable_States
MaBoSS_results<-read.csv('Models/Cohen_MaBoSS_out_fp.csv', sep = "\t",skip=1)
MaBoSS_Probs<-MaBoSS_results$Proba
MaBoSS_Mat<-MaBoSS_results[,4:23]
n<-nrow(MaBoSS_Mat)
maboss_states<-list(rep(NA,n))
for(i in 1:n){
maboss_states[[i]]<-colnames(MaBoSS_Mat)[as.logical(MaBoSS_Mat[i,])]
}
maboss_states
new.order<-rep(0,9)
for (i in 1:9){
for(j in 1:9){
if(all(maboss_states[[i]] %in% Named_Stable_States[[j]]) & length(maboss_states[[i]])==length(Named_Stable_States[[j]])){
print(paste(i,"matched to ",j))
new.order[j]<-i
}
}
}
new.order
plot(Probs,ylim=c(0,.4))
points(MaBoSS_Probs[new.order],col='red')
plot(sort(Probs),ylim=c(0,1))
points(sort(MaBoSS_Probs),col='red')
system.time()
# Probabilities of stable states
Probs<-c()
for (stable in unique(Stable_States)){
count<-0
for (state in Stable_States){
if (all(state==stable)){
count <-count +1
}
}
Probs<-append(Probs,count/N)
}
# Importing MaBoSS results
MaBoSS_results<-read.csv('Models/Cohen_MaBoSS_out_fp.csv', sep = "\t",skip=1)
# Getting probabilities of all 9 stable states
MaBoSS_Probs<-MaBoSS_results$Proba
# Getting all 9 stable states
MaBoSS_Mat<-MaBoSS_results[,4:23]
n<-nrow(MaBoSS_Mat)
maboss_states<-list(rep(NA,n))
for(i in 1:n){
maboss_states[[i]]<-colnames(MaBoSS_Mat)[as.logical(MaBoSS_Mat[i,])]
}
knitr::opts_chunk$set(echo = TRUE)
# Using BoolNet to load bnet data of the simplest model from Cohen 2015
library(BoolNet)
Model<-loadNetwork('Models/CohenSimpleModel.bnet')
# Creating list of genes
Genes<-Model$genes
num.genes<-length(Genes)
# Creating data frame with Gene Name, Gene boolean value (1 or 0), Gene Rule, and Gene degree
Data<-data.frame(Genes=Genes,
Values=sample(c(0,1),num.genes,replace = T),
Rules=rep("none",num.genes),
Degree=rep(0,num.genes))
for (i in 1:num.genes){
# Creating a boolean variable for each gene, with initial value corresponding to its inital value
assign(Genes[i],as.logical(Data$Values[i]))
# Assigning each gene its rule and degree
Data$Rules[i]<-Model$interactions[[i]][3][[1]]
Data$Degree[i]<-length(Model$interactions[[i]][1][[1]])
}
# Turing Genes permanently off or on
#Data$Rules[Data$Genes=='Notch_pthw']<-'TRUE'
#Data$Rules[Data$Genes=='WNT_pthw']<-'TRUE'
# Differentiating input genes which don't change and variable ones that do
Input_Genes<-c('ECMicroenv','DNAdamage')
Variable_Genes<-Genes[!(Genes%in%Input_Genes)]
# Creating list of output genes
Output_Genes<-c('EMT','Migration','Metastasis','Invasion','Apoptosis','CCA')
# Number of Simulations
N<-1000
# Number of steps per simulation
K<-1500
# List of stable state outputs
Stable_States<-list(rep(NA,N))
for(j in 1:N){
# Variable which marks whether the sequence has changed or not
Did.Change<-c(0)
#Creating random initial values of ALL genes
Data$Values<-sample(c(0,1),num.genes,replace = T)
for (i in 1:num.genes){
assign(Genes[i],as.logical(Data$Values[i]))
}
# Defining time series of JUST the variable genes
Time_Series<-Data[Data$Genes %in% Variable_Genes,]
for (k in 1:K){
# Defining current value at start of step k
Cur.Val<-Time_Series$Values
# Vector of exponential times based off the degree of each gene
#Times<-sapply(Time_Series$Degree,function(x){return(rexp(1,x))})
# Activated gene is that with the minimum time
#Gene<-Time_Series$Genes[which(Times==min(Times))]
Gene<-sample(Variable_Genes,1)
# For the given gene,find its rule, current value, and whether it is being activated
Rule<-Data[Data$Genes==Gene,3]
Gen.act<-eval(parse(text=Rule))
cur.val<-Time_Series$Values[Time_Series$Genes==Gene]
# If activated and off, turn on
if (Gen.act & cur.val==0){
Time_Series$Values[Time_Series$Genes==Gene]<-1
assign(Gene,TRUE)
}
# If repressed and on, turn off
else if(!Gen.act & cur.val==1){
Time_Series$Values[Time_Series$Genes==Gene]<-0
assign(Gene,FALSE)
# Else, do nothing
}
# Mark whether the series changed in step k
if (all(Cur.Val==Time_Series$Values)){
Did.Change<-append(Did.Change,0)
}
else{
Did.Change<-append(Did.Change,1)
}
}
# Log the final value of the chain as the stable state for simulation j
#Stable_States[[j]]<-Time_Series$Values[Time_Series$Genes %in% Output_Genes]
Stable_States[[j]]<-c(Data$Values[Data$Genes %in% Input_Genes],Time_Series$Values)
# Plot whether the chain converged
#plot(Did.Change,typ='l')
}
# How many stable states there are (SHOULD BE 9 WITH NO GENE KNOCKOUTS)
length(unique(Stable_States))
# Printing stable states
for (state in unique(Stable_States)){
print(c(Input_Genes,Variable_Genes)[as.logical(state)])
}
# Probabilities of stable states
Probs<-c()
for (stable in unique(Stable_States)){
count<-0
for (state in Stable_States){
if (all(state==stable)){
count <-count +1
}
}
Probs<-append(Probs,count/N)
}
# Importing MaBoSS results
MaBoSS_results<-read.csv('Models/Cohen_MaBoSS_out_fp.csv', sep = "\t",skip=1)
# Getting probabilities of all 9 stable states
MaBoSS_Probs<-MaBoSS_results$Proba
# Getting all 9 stable states
MaBoSS_Mat<-MaBoSS_results[,4:23]
n<-nrow(MaBoSS_Mat)
maboss_states<-list(rep(NA,n))
for(i in 1:n){
maboss_states[[i]]<-colnames(MaBoSS_Mat)[as.logical(MaBoSS_Mat[i,])]
}
# Syncing up MaBoSS states and our states so probabilities match
Named_Stable_States<-list(rep(NA,num.genes))
g<-1
for (state in unique(Stable_States)){
#print(c(rev(Input_Genes),Variable_Genes)[as.logical(state)])
Named_Stable_States[[g]]<-c(rev(Input_Genes),Variable_Genes)[as.logical(state)]
g<-g+1
}
Named_Stable_States
new.order<-rep(0,9)
for (i in 1:9){
for(j in 1:9){
if(all(maboss_states[[i]] %in% Named_Stable_States[[j]]) & length(maboss_states[[i]])==length(Named_Stable_States[[j]])){
print(paste(i,"matched to ",j))
new.order[j]<-i
}
}
}
# Plotting
plot(Probs,ylim=c(0,.4))
points(MaBoSS_Probs[new.order],col='red')
# REDOING SIMULATION ARLGORITHM BASED OFF MABOSS METHOD
# Number of Simulations
N<-10000
# Maximum number of steps per simulation
K<-300
# Size of network
L<-num.genes-length(Input_Genes)
sims<-c()
# List of stable state outputs
Stable_States<-list(rep(NA,N))
for(j in 1:N){
go<-TRUE
#Creating random initial values of ALL genes
#Data$Values[Data$Genes %in% c('ECMicroenv','DNAdamage','GF','TGFb_pthw')]<-sample(c(0,1),4,replace = T)
#Data$Values[!Data$Genes %in% c('ECMicroenv','DNAdamage','GF','TGFb_pthw')]<-rep(0,num.genes-4)
Data$Values<-sample(c(0,1),num.genes,replace=TRUE)
for (i in 1:num.genes){
assign(Genes[i],as.logical(Data$Values[i]))
}
# Defining time series of JUST the variable genes
Time_Series<-Data[Data$Genes %in% Variable_Genes,]
for (k in 1:K){
sim<-1
while(go){
Cur.State<-Time_Series$Values
# Checking which components will change when updated
# I.e. which state changes are an asynchronous transition
Does.Change<-rep(FALSE,L)
for (l in 1:L){
Gen.act<-eval(parse(text=Time_Series$Rules[l]))
# If activated and off, change induced
if (Gen.act & Time_Series$Values[l]==0){
Does.Change[l]<-TRUE
}
# If repressed and on, change induced
if(!Gen.act & Time_Series$Values[l]==1){
Does.Change[l]<-TRUE
}
}
# Creating list of actual step-specific variable genes
Step_Variable_Genes<-Variable_Genes[Does.Change]
#print(Step_Variable_Genes)
if(length(Step_Variable_Genes)==0){
# Log the final value of the chain as the stable state for simulation j
Stable_States[[j]]<-c(Data$Values[Data$Genes %in% Input_Genes],Time_Series$Values)
sims<-append(sims,sim)
go<-FALSE
}
else{
# Then simply repeat the process as before
sim<-sim+1
Gene<-sample(Step_Variable_Genes,1)
# For the given gene,find its rule, current value, and whether it is being activated
Rule<-Data[Data$Genes==Gene,3]
Gen.act<-eval(parse(text=Rule))
cur.val<-Time_Series$Values[Time_Series$Genes==Gene]
# If activated and off, turn on
if (Gen.act & cur.val==0){
Time_Series$Values[Time_Series$Genes==Gene]<-1
assign(Gene,TRUE)
}
# If repressed and on, turn off
else if(!Gen.act & cur.val==1){
Time_Series$Values[Time_Series$Genes==Gene]<-0
assign(Gene,FALSE)
# Else, do nothing
}
}
}
}
}
# How many stable states there are (SHOULD BE 9 WITH NO GENE KNOCKOUTS)
length(unique(Stable_States))
# Probabilities of stable states
Probs<-c()
for (stable in unique(Stable_States)){
count<-0
for (state in Stable_States){
if (all(state==stable)){
count <-count +1
}
}
Probs<-append(Probs,count/N)
}
# Importing MaBoSS results
MaBoSS_results<-read.csv('Models/Cohen_MaBoSS_out_fp.csv', sep = "\t",skip=1)
# Getting probabilities of all 9 stable states
MaBoSS_Probs<-MaBoSS_results$Proba
# Getting all 9 stable states
MaBoSS_Mat<-MaBoSS_results[,4:23]
n<-nrow(MaBoSS_Mat)
maboss_states<-list(rep(NA,n))
for(i in 1:n){
maboss_states[[i]]<-colnames(MaBoSS_Mat)[as.logical(MaBoSS_Mat[i,])]
}
# Syncing up MaBoSS states and our states so probabilities match
Named_Stable_States<-list(rep(NA,num.genes))
g<-1
for (state in unique(Stable_States)){
#print(c(rev(Input_Genes),Variable_Genes)[as.logical(state)])
Named_Stable_States[[g]]<-c(rev(Input_Genes),Variable_Genes)[as.logical(state)]
g<-g+1
}
Named_Stable_States
new.order<-rep(0,9)
for (i in 1:9){
for(j in 1:9){
if(all(maboss_states[[i]] %in% Named_Stable_States[[j]]) & length(maboss_states[[i]])==length(Named_Stable_States[[j]])){
print(paste(i,"matched to ",j))
new.order[j]<-i
}
}
}
# Plotting
plot(Probs,ylim=c(0,.4))
points(MaBoSS_Probs[new.order],col='red')
