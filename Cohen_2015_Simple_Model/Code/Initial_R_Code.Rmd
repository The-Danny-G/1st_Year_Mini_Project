---
title: "Initial R Code"
author: "Daniel Gardner"
date: "2024-02-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup

Here I import the model as used in the paper and then create the data frame we will be using throughout the code.

To begin with, I used the model in its BoolNet form (.bnet), as sometimes loading from SBML form was unreliable. However using either `loadNetwork()` for a .bnet file or `loadSBML()` for an .SBML file load the same model. The model consists of a list of three sections:

-   `genes`: a character list of all genes (nodes) used in the model

-   `fixed`: a vector of all genes to flag whether a gene would be 'fixed' during the simulation

-   `interactions`: a list of all genes, each containing a list of all the gene's input nodes, their Boolean rule, and the Boolean rule in truth table format

Using this, I then created a dataset consisting of:

-   Genes: the character list of all genes

-   Values: The Boolean value of each gene (i.e. 0 or 1)

-   Rules: The Boolean rule of each gene, stored as a character of a Boolean rule

-   Degree: The number of input nodes going into each gene

I also created an individual Boolean variable for each gene, so this way when using `eval(parse(text=Rule))` , the function returned a Boolean output.

I also made sure to differentiate the input genes, 'variable genes' which would change during the time series, and output genes.

Finally whilst currently commented out, I used this chunk to store initial conditions for now, such as turning one or multiple genes either permanently off or on (i.e. setting both their variable and Boolean rule to 'TRUE'/'FALSE').

```{r warning=FALSE}
# Using BoolNet to load bnet data of the simplest model from Cohen 2015
library(BoolNet)
Model<-loadNetwork('Models/CohenSimpleModel.bnet')

# Creating list of genes
Genes<-Model$genes
num.genes<-length(Genes)

# Creating data frame with Gene Name, Gene boolean value (1 or 0), Gene Rule, and Gene degree
Data<-data.frame(Genes=Genes,
                 Values=sample(c(0,1),num.genes,replace = T),
                 Rules=rep("none",num.genes),
                 Degree=rep(0,num.genes))

for (i in 1:num.genes){
  # Creating a boolean variable for each gene, with initial value corresponding to its inital value
  assign(Genes[i],as.logical(Data$Values[i]))
  # Assigning each gene its rule and degree
  Data$Rules[i]<-Model$interactions[[i]][3][[1]]
  Data$Degree[i]<-length(Model$interactions[[i]][1][[1]])
}

# Turing Genes permanently off or on

#Data$Rules[Data$Genes=='Notch_pthw']<-'TRUE'
#Data$Rules[Data$Genes=='WNT_pthw']<-'TRUE'

# Differentiating input genes which don't change and variable ones that do
Input_Genes<-c('ECMicroenv','DNAdamage')
Variable_Genes<-Genes[!(Genes%in%Input_Genes)]

# Creating list of output genes
Output_Genes<-c('EMT','Migration','Metastasis','Invasion','Apoptosis','CCA')
```

# Simulation 1: Component-wise changes

Here I run N=2000 simulations of the discrete time Markov chain model of simulation, using K=1500 steps for each simulation. For each simulation, I randomised the value of ALL genes, including the two input genes. I then performed the Markov chain simulation on all variable genes, picking the gene to be updated at each step either uniformly random or using the 'exponential clock' method. (Note that the latter is much slower).

Whilst currently commented out, I sometimes plotted a graph of how many times the Markov chain changed over the 1500 steps, just to verify that it had converged.

```{r}
# Number of Simulations
N<-1000

# Number of steps per simulation
K<-1500

# List of stable state outputs
Stable_States<-list(rep(NA,N))

for(j in 1:N){
  
    # Variable which marks whether the sequence has changed or not
    Did.Change<-c(0)
    
    #Creating random initial values of ALL genes
    Data$Values<-sample(c(0,1),num.genes,replace = T)
    for (i in 1:num.genes){
    assign(Genes[i],as.logical(Data$Values[i]))
    }
    
    # Defining time series of JUST the variable genes
    Time_Series<-Data[Data$Genes %in% Variable_Genes,]
  
  for (k in 1:K){
      
      # Defining current value at start of step k
      Cur.Val<-Time_Series$Values
      
      # Vector of exponential times based off the degree of each gene
      #Times<-sapply(Time_Series$Degree,function(x){return(rexp(1,x))})
      # Activated gene is that with the minimum time
      #Gene<-Time_Series$Genes[which(Times==min(Times))]
      Gene<-sample(Variable_Genes,1)
      
      
      # For the given gene,find its rule, current value, and whether it is being activated
      Rule<-Data[Data$Genes==Gene,3]
      Gen.act<-eval(parse(text=Rule))
      cur.val<-Time_Series$Values[Time_Series$Genes==Gene]
      
      # If activated and off, turn on
      if (Gen.act & cur.val==0){
        Time_Series$Values[Time_Series$Genes==Gene]<-1
        assign(Gene,TRUE)
      
    }
      # If repressed and on, turn off
      else if(!Gen.act & cur.val==1){
        Time_Series$Values[Time_Series$Genes==Gene]<-0
        assign(Gene,FALSE)
        
      # Else, do nothing
      
      }
      
      # Mark whether the series changed in step k
      if (all(Cur.Val==Time_Series$Values)){
        Did.Change<-append(Did.Change,0)
      }
      else{
        Did.Change<-append(Did.Change,1)
      }
      
  }
    # Log the final value of the chain as the stable state for simulation j
    #Stable_States[[j]]<-Time_Series$Values[Time_Series$Genes %in% Output_Genes]
    Stable_States[[j]]<-c(Data$Values[Data$Genes %in% Input_Genes],Time_Series$Values)
    # Plot whether the chain converged
    #plot(Did.Change,typ='l')
}


# How many stable states there are (SHOULD BE 9 WITH NO GENE KNOCKOUTS)  
length(unique(Stable_States))
```

Now that the amount of stable states matched that given by MaBoSS and GINsim, I can check whether the states match up. To do this I simply matched the output of the Time Series (a string of 1s and 0s) to a character list of all genes.

```{r}
# Printing stable states
for (state in unique(Stable_States)){
  print(c(Input_Genes,Variable_Genes)[as.logical(state)])
}
```

I then attempted to estimate the probability of being in each state simply by calculating the proportions of each unique steady state over all steady states. I then checked these probabilities visually against the probabilities returned by MaBoSS for the same experiment. Whilst there is no standard order of stable states so the order may be different, you would expect the values to still match. However when looking at the two graphs we can see this is currently not the case.

```{r}
# Probabilities of stable states

Probs<-c()
for (stable in unique(Stable_States)){
  count<-0
  for (state in Stable_States){
    if (all(state==stable)){
      count <-count +1
    }
  }
  Probs<-append(Probs,count/N)
}
```

```{r}
# Importing MaBoSS results
MaBoSS_results<-read.csv('Models/Cohen_MaBoSS_out_fp.csv', sep = "\t",skip=1)

# Getting probabilities of all 9 stable states
MaBoSS_Probs<-MaBoSS_results$Proba

# Getting all 9 stable states
MaBoSS_Mat<-MaBoSS_results[,4:23]
n<-nrow(MaBoSS_Mat)
maboss_states<-list(rep(NA,n))
for(i in 1:n){
  
  maboss_states[[i]]<-colnames(MaBoSS_Mat)[as.logical(MaBoSS_Mat[i,])]
  
}
```

```{r}
# Syncing up MaBoSS states and our states so probabilities match

Named_Stable_States<-list(rep(NA,num.genes))
g<-1
for (state in unique(Stable_States)){
  #print(c(rev(Input_Genes),Variable_Genes)[as.logical(state)])
  Named_Stable_States[[g]]<-c(rev(Input_Genes),Variable_Genes)[as.logical(state)]
  g<-g+1
}

new.order<-rep(0,9)
for (i in 1:9){
  
  for(j in 1:9){
    
    if(all(maboss_states[[i]] %in% Named_Stable_States[[j]]) & length(maboss_states[[i]])==length(Named_Stable_States[[j]])){
      
      new.order[j]<-i
    }
  
  }

}

```

```{r}
# Plotting
plot(Probs,ylim=c(0,.4))
points(MaBoSS_Probs[new.order],col='red')
```

# Simulation 2: State-wise changes

I now chose to follow the algorithm as described in the Stoll et. al. (2012) paper explicitly, changing the state each time instead of the component. Essentially the main change here is that from each state, I check each component to see if it is currently being activated or repressed, and then randomly select one of THESE components to update instead of all components.

This way, an update to the state happens at every step instead of randomly, with lots of steps having nothing happen. This also makes it easier to show convergence, since when we reach a state such that no component is being affected, we know for certain we have reached a steady state. This improves the efficiency of the algorithm greatly.

```{r}
# REDOING SIMULATION ARLGORITHM BASED OFF MABOSS METHOD

# Number of Simulations
N<-10000

# Maximum number of steps per simulation
K<-300

# Size of network
L<-num.genes-length(Input_Genes)

sims<-c()

# List of stable state outputs
Stable_States<-list(rep(NA,N))

for(j in 1:N){
  
    go<-TRUE
    
    #Creating random initial values of ALL genes
    #Data$Values[Data$Genes %in% c('ECMicroenv','DNAdamage','GF','TGFb_pthw')]<-sample(c(0,1),4,replace = T)
    #Data$Values[!Data$Genes %in% c('ECMicroenv','DNAdamage','GF','TGFb_pthw')]<-rep(0,num.genes-4)
    Data$Values<-sample(c(0,1),num.genes,replace=TRUE)
    
    for (i in 1:num.genes){
    assign(Genes[i],as.logical(Data$Values[i]))
    }
    
    # Defining time series of JUST the variable genes
    Time_Series<-Data[Data$Genes %in% Variable_Genes,]
  
  for (k in 1:K){
    
    sim<-1
    
    while(go){
      
          Cur.State<-Time_Series$Values
    
          # Checking which components will change when updated
          # I.e. which state changes are an asynchronous transition
          
          Does.Change<-rep(FALSE,L)
          for (l in 1:L){
            
              Gen.act<-eval(parse(text=Time_Series$Rules[l]))
              # If activated and off, change induced
              if (Gen.act & Time_Series$Values[l]==0){
                Does.Change[l]<-TRUE
            }
              # If repressed and on, change induced
              if(!Gen.act & Time_Series$Values[l]==1){
                Does.Change[l]<-TRUE
              }
            
          }
          
          # Creating list of actual step-specific variable genes
          Step_Variable_Genes<-Variable_Genes[Does.Change]
          #print(Step_Variable_Genes)
          
          if(length(Step_Variable_Genes)==0){
            # Log the final value of the chain as the stable state for simulation j
            Stable_States[[j]]<-c(Data$Values[Data$Genes %in% Input_Genes],Time_Series$Values)
            sims<-append(sims,sim)
            go<-FALSE
            
            
          }
          
          else{
            
                # Then simply repeat the process as before
                sim<-sim+1
              
                Gene<-sample(Step_Variable_Genes,1)
                
                
                # For the given gene,find its rule, current value, and whether it is being activated
                Rule<-Data[Data$Genes==Gene,3]
                Gen.act<-eval(parse(text=Rule))
                cur.val<-Time_Series$Values[Time_Series$Genes==Gene]
                
                # If activated and off, turn on
                if (Gen.act & cur.val==0){
                  Time_Series$Values[Time_Series$Genes==Gene]<-1
                  assign(Gene,TRUE)
                
              }
                # If repressed and on, turn off
                else if(!Gen.act & cur.val==1){
                  Time_Series$Values[Time_Series$Genes==Gene]<-0
                  assign(Gene,FALSE)
                  
                # Else, do nothing
                
                }
            
          }
      
      
    }

    
      
    
    
      
  }
    
}


# How many stable states there are (SHOULD BE 9 WITH NO GENE KNOCKOUTS)  
length(unique(Stable_States))
```

Again we check our estimate of probabilities against the MaBoSS predictions.

```{r}
# Probabilities of stable states

Probs<-c()
for (stable in unique(Stable_States)){
  count<-0
  for (state in Stable_States){
    if (all(state==stable)){
      count <-count +1
    }
  }
  Probs<-append(Probs,count/N)
}
```

```{r}
# Importing MaBoSS results
MaBoSS_results<-read.csv('Models/Cohen_MaBoSS_out_fp.csv', sep = "\t",skip=1)

# Getting probabilities of all 9 stable states
MaBoSS_Probs<-MaBoSS_results$Proba

# Getting all 9 stable states
MaBoSS_Mat<-MaBoSS_results[,4:23]
n<-nrow(MaBoSS_Mat)
maboss_states<-list(rep(NA,n))
for(i in 1:n){
  
  maboss_states[[i]]<-colnames(MaBoSS_Mat)[as.logical(MaBoSS_Mat[i,])]
  
}
```

```{r}
# Syncing up MaBoSS states and our states so probabilities match

Named_Stable_States<-list(rep(NA,num.genes))
g<-1
for (state in unique(Stable_States)){
  #print(c(rev(Input_Genes),Variable_Genes)[as.logical(state)])
  Named_Stable_States[[g]]<-c(rev(Input_Genes),Variable_Genes)[as.logical(state)]
  g<-g+1
}

new.order<-rep(0,9)
for (i in 1:9){
  
  for(j in 1:9){
    
    if(all(maboss_states[[i]] %in% Named_Stable_States[[j]]) & length(maboss_states[[i]])==length(Named_Stable_States[[j]])){
      
      new.order[j]<-i
    }
  
  }

}

```

```{r}
# Plotting
plot(Probs,ylim=c(0,.4))
points(MaBoSS_Probs[new.order],col='red')
```




