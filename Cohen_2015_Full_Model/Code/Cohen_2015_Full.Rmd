---
title: "Cohen_Full"
author: "Daniel Gardner"
date: "2024-02-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup

Here I import the model as used in the paper and then create the data frame we will be using throughout the code.

To begin with, I used the model in its BoolNet form (.bnet), as sometimes loading from SBML form was unreliable. However using either `loadNetwork()` for a .bnet file or `loadSBML()` for an .SBML file load the same model. The model consists of a list of three sections:

-   `genes`: a character list of all genes (nodes) used in the model

-   `fixed`: a vector of all genes to flag whether a gene would be 'fixed' during the simulation

-   `interactions`: a list of all genes, each containing a list of all the gene's input nodes, their Boolean rule, and the Boolean rule in truth table format

Using this, I then created a dataset consisting of:

-   Genes: the character list of all genes

-   Values: The Boolean value of each gene (i.e. 0 or 1)

-   Rules: The Boolean rule of each gene, stored as a character of a Boolean rule

-   Degree: The number of input nodes going into each gene

I also created an individual Boolean variable for each gene, so this way when using `eval(parse(text=Rule))` , the function returned a Boolean output.

I also made sure to differentiate the input genes, 'variable genes' which would change during the time series, and output genes.

Finally whilst currently commented out, I used this chunk to store initial conditions for now, such as turning one or multiple genes either permanently off or on (i.e. setting both their variable and Boolean rule to 'TRUE'/'FALSE').

```{r warning=FALSE}
# Using BoolNet to load bnet data of the simplest model from Cohen 2015
library(BoolNet)
Model<-loadNetwork('Models/Cohen_Full.bnet')

# Creating list of genes
Genes<-Model$genes
num.genes<-length(Genes)

# Creating data frame with Gene Name, Gene boolean value (1 or 0), Gene Rule, and Gene degree
Data<-data.frame(Genes=Genes,
                 Values=sample(c(0,1),num.genes,replace = T),
                 Rules=rep("none",num.genes),
                 Degree=rep(0,num.genes))

for (i in 1:num.genes){
  # Creating a boolean variable for each gene, with initial value corresponding to its inital value
  assign(Genes[i],as.logical(Data$Values[i]))
  # Assigning each gene its rule and degree
  Data$Rules[i]<-Model$interactions[[i]][3][[1]]
  Data$Degree[i]<-length(Model$interactions[[i]][1][[1]])
}

# Turing Genes permanently off or on

#Data$Rules[Data$Genes=='p53']<-'TRUE'
#Data$Rules[Data$Genes=='miR34']<-'TRUE'
#Data$Rules[Data$Genes=='ERK']<-'TRUE'

# Differentiating input genes which don't change and variable ones that do
Input_Genes<-c('ECMicroenv','DNAdamage')
Variable_Genes<-Genes[!(Genes%in%Input_Genes)]

# Creating list of output genes
Output_Genes<-c('EMT','Migration','Metastasis','Invasion','Apoptosis','CellCycleArrest')
```

# Simulation

Here I run N=1500 simulations of the discrete time Markov chain model of simulation, using K=1000 steps for each simulation. For each simulation, I randomised the value of ALL genes, including the two input genes. I then performed the Markov chain simulation on all variable genes, picking the gene to be updated at each step either uniformly random or using the 'exponential clock' method. (Note that the latter is much slower).

Whilst currently commented out, I sometimes plotted a graph of how many times the Markov chain changed over the 1500 steps, just to verify that it had converged.

```{r}
# Number of Simulations
N<-1500

# Number of steps per simulation
K<-1000

# List of stable state outputs
Stable_States<-list(rep(NA,N))

for(j in 1:N){
  
    # Variable which marks whether the sequence has changed or not
    Did.Change<-c(0)
    
    #Creating random initial values of ALL genes
    Data$Values<-sample(c(0,1),num.genes,replace = T)
    for (i in 1:num.genes){
    assign(Genes[i],as.logical(Data$Values[i]))
    }
    
    # Defining time series of JUST the variable genes
    Time_Series<-Data[Data$Genes %in% Variable_Genes,]
  
  for (k in 1:K){
      
      # Defining current value at start of step k
      Cur.Val<-Time_Series$Values
      
      # Vector of exponential times based off the degree of each gene
      #Times<-sapply(Time_Series$Degree,function(x){return(rexp(1,x))})
      # Activated gene is that with the minimum time
      #Gene<-Time_Series$Genes[which(Times==min(Times))]
      Gene<-sample(Variable_Genes,1)
      
      
      # For the given gene,find its rule, current value, and whether it is being activated
      Rule<-Data[Data$Genes==Gene,3]
      Gen.act<-eval(parse(text=Rule))
      cur.val<-Time_Series$Values[Time_Series$Genes==Gene]
      
      # If activated and off, turn on
      if (Gen.act & cur.val==0){
        Time_Series$Values[Time_Series$Genes==Gene]<-1
        assign(Gene,TRUE)
      
    }
      # If repressed and on, turn off
      else if(!Gen.act & cur.val==1){
        Time_Series$Values[Time_Series$Genes==Gene]<-0
        assign(Gene,FALSE)
        
      # Else, do nothing
      
      }
      
      # Mark whether the series changed in step k
      if (all(Cur.Val==Time_Series$Values)){
        Did.Change<-append(Did.Change,0)
      }
      else{
        Did.Change<-append(Did.Change,1)
      }
      
  }
    # Log the final value of the chain as the stable state for simulation j
    #Stable_States[[j]]<-Time_Series$Values[Time_Series$Genes %in% Output_Genes]
    Stable_States[[j]]<-c(Time_Series$Values,Data$Values[Data$Genes %in% Input_Genes])
    # Plot whether the chain converged
    #plot(Did.Change,typ='l')
}


# How many stable states there are 
length(unique(Stable_States))
```

```{r}
# Printing stable states
for (state in unique(Stable_States)){
  print(c(Variable_Genes,Input_Genes)[as.logical(state)])
}
```



